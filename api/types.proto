syntax = "proto3";

package api;

// NOTE(stevvooe): Make sure your gopath is appropriately set for this to work
// correctly.
import "github.com/gogo/protobuf/gogoproto/gogo.proto";

// TODO(stevvooe): Move these options to vanity binary (ie gogoswarm).

option (gogoproto.gostring_all) = true;
option (gogoproto.goproto_getters_all) = false;
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) =  true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;

message Node {
	string id = 1;
	string name = 2;
	string ip = 4;

	NodeStatus status = 3;

	// TODO(stevvooe): Define resources for the node (ie cpu, memory, local
	// volumes, etc.).
}

enum NodeStatus {
	UNKNOWN = 0;
	DOWN = 1; 
	READY = 2;
	DRAINED = 3; // needs differentation of desired and observed state.
}

// TODO(stevvooe): Add QueryOptions types with pagination parameters. Needs to
// be common to every request type. Define common service primitives in
// services.proto. Each service should have single proto file.

// Meta is common to all API objects types.
message Meta {
	// TODO(stevvooe): Consider an ID here. Probably not.

	string name = 1;
	map<string, string> labels = 2;
}

message ImageSpec {
	Meta meta = 1;

	// Resolved is the image resolved by the swarm cluster. This may be
	// identical, depending on the name provided in meta. For example, the name
	// field may be "redis", whereas this field would specify the exact hash,
	// "redis@sha256:...".
	//
	// A user may set this field to bypass swarms resolution.
	string resolved = 2; // TODO(stevvooe): Field type should be reference.Field.
}

message ContainerSpec {
	Meta meta = 1;	
	ImageSpec image = 2;

	// Config specifies the swarm support runtime configuration. This will take
	// on many aspects of the existing Container config and Host config,
	// restricted to swarm support fields.
	ContainerConfig config = 3;
}

message ContainerConfig {
	// TODO(stevvooe): Extract fields from existing host configuration.
}

// Bundle is a reserved history type from the POC. We have this here to test
// the concept of multi-dispatch tasks, which is a design goal.
message Bundle {
	Meta meta = 1;	

	// remote specifies a URL to fetch task bundle data. This can either
	// be a git repository or blobster repository.
	string remote = 2;
	string bundle = 3; // bundle is the commitish of the bundle
	string entrypoint = 4; // some specification for what to run.
}

// PODSpec defines a specification for a pod bundle.
message PODSpec {
	Bundle bundle = 1;
}

// NOTE(stevvooe): Don't panic. We can remove the above pod types.


// Spec defines the properties of a Job. As tasks are created, they gain the
// Job specification.
//
// There are two key components to a spec. The first is a "source". A source
// defines runnable content. For the swarm use case, this is a container but we
// may extend it to provide other kinds of runnable targets. The second
// component is the "orchestration". The orchestration defines the strategy
// used to the schedule and run the target with a cluster.
message Spec {
	Meta meta = 1;
	
	message Source { // TODO(stevvooe): better name?
		oneof source {
			ContainerSpec container = 1;
			PODSpec pod = 2;	
		}
	}
	
	message ServiceJob {
       int64 instances = 1;
	}

	message BatchJob {
       int64 completions = 1;
       int64 paralellism = 2;
	}

	message GlobalJob {
	}

	message CronJob {
	}

	message Orchestration { // TODO(stevvooe): Consider calling this strategy.
		oneof job {
			ServiceJob service = 1;
			BatchJob batch = 2;
            GlobalJob global = 3;
            CronJob cron = 4;
		}
	}
	
	Source source = 2;
	Orchestration orchestration = 3;
}

message TaskStatus {
	enum State {
		NEW = 0;
		ASSIGNED = 1;
		PREPARING = 2;
		READY = 3;
		STARTING = 4;
		RUNNING = 5;
		SHUTDOWN = 6;
		COMPLETE = 7; // successful completion of task (not error code, just ran)
		FAILED = 8; // task execution failed with error
		REJECTED = 9; // task could not be executed here.
		FINALIZE = 10; // when task is deallocated from node, waiting on cleanup
		DEAD = 11; // completely finished, unallocated task.
	}

	State state = 2;
	string message = 3;
}


message Task {
	string id = 1;
	string job_id = 2;

	// TODO(stevvooe): Consider bringing back assignment, rather than using a
	// node id field. We like having this concept be first-class. It helps to
	// reason about storage and consistency.

	string node_id = 3; // if not set, the task is unassigned.

	// NOTE(stevvooe): Spec, status or both may be set, depending on the role
	// of this message.

	Spec spec = 4;
	TaskStatus status = 5;

	// Networking state

	// TODO(stevvooe): Move these. Not sure where in the model yet. These are
	// resources allocated to a task, so they may belong here but as a
	// submessage.
	string net_id = 6;
	string ep_id = 7;
	string ip = 8;
	string gateway = 9;
	repeated string driver_info = 10;
}

message Job {
	string id = 1;
	Spec spec = 2;
}

