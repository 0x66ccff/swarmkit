// Code generated by protoc-gen-gogo.
// source: master.proto
// DO NOT EDIT!

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Update struct {
	// Types that are valid to be assigned to Update:
	//	*Update_UpdateNode
	//	*Update_UpdateTask
	//	*Update_UpdateJob
	//	*Update_DeleteNode
	//	*Update_DeleteTask
	//	*Update_DeleteJob
	Update isUpdate_Update `protobuf_oneof:"update"`
}

func (m *Update) Reset()      { *m = Update{} }
func (*Update) ProtoMessage() {}

type isUpdate_Update interface {
	isUpdate_Update()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Update_UpdateNode struct {
	UpdateNode *Node `protobuf:"bytes,1,opt,name=updateNode,oneof"`
}
type Update_UpdateTask struct {
	UpdateTask *Task `protobuf:"bytes,2,opt,name=updateTask,oneof"`
}
type Update_UpdateJob struct {
	UpdateJob *Job `protobuf:"bytes,4,opt,name=updateJob,oneof"`
}
type Update_DeleteNode struct {
	DeleteNode string `protobuf:"bytes,5,opt,name=deleteNode,proto3,oneof"`
}
type Update_DeleteTask struct {
	DeleteTask string `protobuf:"bytes,6,opt,name=deleteTask,proto3,oneof"`
}
type Update_DeleteJob struct {
	DeleteJob string `protobuf:"bytes,8,opt,name=deleteJob,proto3,oneof"`
}

func (*Update_UpdateNode) isUpdate_Update() {}
func (*Update_UpdateTask) isUpdate_Update() {}
func (*Update_UpdateJob) isUpdate_Update()  {}
func (*Update_DeleteNode) isUpdate_Update() {}
func (*Update_DeleteTask) isUpdate_Update() {}
func (*Update_DeleteJob) isUpdate_Update()  {}

func (m *Update) GetUpdate() isUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Update) GetUpdateNode() *Node {
	if x, ok := m.GetUpdate().(*Update_UpdateNode); ok {
		return x.UpdateNode
	}
	return nil
}

func (m *Update) GetUpdateTask() *Task {
	if x, ok := m.GetUpdate().(*Update_UpdateTask); ok {
		return x.UpdateTask
	}
	return nil
}

func (m *Update) GetUpdateJob() *Job {
	if x, ok := m.GetUpdate().(*Update_UpdateJob); ok {
		return x.UpdateJob
	}
	return nil
}

func (m *Update) GetDeleteNode() string {
	if x, ok := m.GetUpdate().(*Update_DeleteNode); ok {
		return x.DeleteNode
	}
	return ""
}

func (m *Update) GetDeleteTask() string {
	if x, ok := m.GetUpdate().(*Update_DeleteTask); ok {
		return x.DeleteTask
	}
	return ""
}

func (m *Update) GetDeleteJob() string {
	if x, ok := m.GetUpdate().(*Update_DeleteJob); ok {
		return x.DeleteJob
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Update) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Update_OneofMarshaler, _Update_OneofUnmarshaler, []interface{}{
		(*Update_UpdateNode)(nil),
		(*Update_UpdateTask)(nil),
		(*Update_UpdateJob)(nil),
		(*Update_DeleteNode)(nil),
		(*Update_DeleteTask)(nil),
		(*Update_DeleteJob)(nil),
	}
}

func _Update_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Update)
	// update
	switch x := m.Update.(type) {
	case *Update_UpdateNode:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UpdateNode); err != nil {
			return err
		}
	case *Update_UpdateTask:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UpdateTask); err != nil {
			return err
		}
	case *Update_UpdateJob:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UpdateJob); err != nil {
			return err
		}
	case *Update_DeleteNode:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DeleteNode)
	case *Update_DeleteTask:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DeleteTask)
	case *Update_DeleteJob:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DeleteJob)
	case nil:
	default:
		return fmt.Errorf("Update.Update has unexpected type %T", x)
	}
	return nil
}

func _Update_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Update)
	switch tag {
	case 1: // update.updateNode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.Update = &Update_UpdateNode{msg}
		return true, err
	case 2: // update.updateTask
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Task)
		err := b.DecodeMessage(msg)
		m.Update = &Update_UpdateTask{msg}
		return true, err
	case 4: // update.updateJob
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Job)
		err := b.DecodeMessage(msg)
		m.Update = &Update_UpdateJob{msg}
		return true, err
	case 5: // update.deleteNode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Update = &Update_DeleteNode{x}
		return true, err
	case 6: // update.deleteTask
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Update = &Update_DeleteTask{x}
		return true, err
	case 8: // update.deleteJob
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Update = &Update_DeleteJob{x}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterType((*Update)(nil), "api.Update")
}
func (this *Update) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&api.Update{")
	if this.Update != nil {
		s = append(s, "Update: "+fmt.Sprintf("%#v", this.Update)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Update_UpdateNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_UpdateNode{` +
		`UpdateNode:` + fmt.Sprintf("%#v", this.UpdateNode) + `}`}, ", ")
	return s
}
func (this *Update_UpdateTask) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_UpdateTask{` +
		`UpdateTask:` + fmt.Sprintf("%#v", this.UpdateTask) + `}`}, ", ")
	return s
}
func (this *Update_UpdateJob) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_UpdateJob{` +
		`UpdateJob:` + fmt.Sprintf("%#v", this.UpdateJob) + `}`}, ", ")
	return s
}
func (this *Update_DeleteNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_DeleteNode{` +
		`DeleteNode:` + fmt.Sprintf("%#v", this.DeleteNode) + `}`}, ", ")
	return s
}
func (this *Update_DeleteTask) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_DeleteTask{` +
		`DeleteTask:` + fmt.Sprintf("%#v", this.DeleteTask) + `}`}, ", ")
	return s
}
func (this *Update_DeleteJob) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&api.Update_DeleteJob{` +
		`DeleteJob:` + fmt.Sprintf("%#v", this.DeleteJob) + `}`}, ", ")
	return s
}
func valueToGoStringMaster(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringMaster(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Master service

type MasterClient interface {
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

// Server API for Master service

type MasterServer interface {
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Master",
	HandlerType: (*MasterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
}

func (m *Update) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Update) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		nn1, err := m.Update.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Update_UpdateNode) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.UpdateNode != nil {
		data[i] = 0xa
		i++
		i = encodeVarintMaster(data, i, uint64(m.UpdateNode.Size()))
		n2, err := m.UpdateNode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Update_UpdateTask) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.UpdateTask != nil {
		data[i] = 0x12
		i++
		i = encodeVarintMaster(data, i, uint64(m.UpdateTask.Size()))
		n3, err := m.UpdateTask.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Update_UpdateJob) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.UpdateJob != nil {
		data[i] = 0x22
		i++
		i = encodeVarintMaster(data, i, uint64(m.UpdateJob.Size()))
		n4, err := m.UpdateJob.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Update_DeleteNode) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x2a
	i++
	i = encodeVarintMaster(data, i, uint64(len(m.DeleteNode)))
	i += copy(data[i:], m.DeleteNode)
	return i, nil
}
func (m *Update_DeleteTask) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x32
	i++
	i = encodeVarintMaster(data, i, uint64(len(m.DeleteTask)))
	i += copy(data[i:], m.DeleteTask)
	return i, nil
}
func (m *Update_DeleteJob) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x42
	i++
	i = encodeVarintMaster(data, i, uint64(len(m.DeleteJob)))
	i += copy(data[i:], m.DeleteJob)
	return i, nil
}
func encodeFixed64Master(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Master(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMaster(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Update) Size() (n int) {
	var l int
	_ = l
	if m.Update != nil {
		n += m.Update.Size()
	}
	return n
}

func (m *Update_UpdateNode) Size() (n int) {
	var l int
	_ = l
	if m.UpdateNode != nil {
		l = m.UpdateNode.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	return n
}
func (m *Update_UpdateTask) Size() (n int) {
	var l int
	_ = l
	if m.UpdateTask != nil {
		l = m.UpdateTask.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	return n
}
func (m *Update_UpdateJob) Size() (n int) {
	var l int
	_ = l
	if m.UpdateJob != nil {
		l = m.UpdateJob.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	return n
}
func (m *Update_DeleteNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.DeleteNode)
	n += 1 + l + sovMaster(uint64(l))
	return n
}
func (m *Update_DeleteTask) Size() (n int) {
	var l int
	_ = l
	l = len(m.DeleteTask)
	n += 1 + l + sovMaster(uint64(l))
	return n
}
func (m *Update_DeleteJob) Size() (n int) {
	var l int
	_ = l
	l = len(m.DeleteJob)
	n += 1 + l + sovMaster(uint64(l))
	return n
}

func sovMaster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMaster(x uint64) (n int) {
	return sovMaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Update) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update{`,
		`Update:` + fmt.Sprintf("%v", this.Update) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_UpdateNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_UpdateNode{`,
		`UpdateNode:` + strings.Replace(fmt.Sprintf("%v", this.UpdateNode), "Node", "Node", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_UpdateTask) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_UpdateTask{`,
		`UpdateTask:` + strings.Replace(fmt.Sprintf("%v", this.UpdateTask), "Task", "Task", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_UpdateJob) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_UpdateJob{`,
		`UpdateJob:` + strings.Replace(fmt.Sprintf("%v", this.UpdateJob), "Job", "Job", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_DeleteNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_DeleteNode{`,
		`DeleteNode:` + fmt.Sprintf("%v", this.DeleteNode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_DeleteTask) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_DeleteTask{`,
		`DeleteTask:` + fmt.Sprintf("%v", this.DeleteTask) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update_DeleteJob) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update_DeleteJob{`,
		`DeleteJob:` + fmt.Sprintf("%v", this.DeleteJob) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMaster(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Update) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &Update_UpdateNode{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Task{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &Update_UpdateTask{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Job{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &Update_UpdateJob{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = &Update_DeleteNode{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = &Update_DeleteTask{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteJob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = &Update_DeleteJob{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaster(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMaster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMaster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMaster(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMaster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaster   = fmt.Errorf("proto: integer overflow")
)
